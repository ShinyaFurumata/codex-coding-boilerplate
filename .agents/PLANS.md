# Codex 実行計画（ExecPlan）ガイドライン

このドキュメントでは、コーディングエージェントが機能実装やシステム変更を確実に遂行するための設計文書「実行計画（ExecPlan）」の要件について説明します。読み手は、このリポジトリについて何も知らない初心者として扱ってください。彼らが持っているのは、現在の作業ツリーとあなたが提供する単一の ExecPlan ファイルのみです。過去の計画の記憶や外部コンテキストは一切存在しません。

## ExecPlan と PLANS.md の活用方法

### 仕様書作成時の心得

実行可能な仕様書（ExecPlan）を作成する際は、PLANS.md に**一字一句**従ってください。もしコンテキストにない場合は、PLANS.md ファイル全体を読み返して記憶を新たにしてください。正確な仕様書を作成するために、ソース資料を徹底的に読み込み（何度も読み返し）ましょう。仕様書作成時は、骨組みから始めて、調査を進めながら肉付けしていきます。

### 実装時の心得

実行可能な仕様書（ExecPlan）を実装する際は、ユーザーに「次のステップ」を尋ねることなく、単純に次のマイルストーンへ進んでください。すべてのセクションを最新状態に保ち、作業の区切りごとにリストの項目を追加・分割して、進捗状況と次のステップを明確に記録します。曖昧な点は自律的に解決し、頻繁にコミットしてください。

### 議論・検討時の心得

実行可能な仕様書（ExecPlan）について議論する際は、後世のために仕様書内のログに決定事項を記録してください。仕様変更の理由は明確に記載されるべきです。ExecPlan は生きた文書であり、ExecPlan のみから作業を再開できる状態を常に維持する必要があります。

### 調査・検証時の心得

技術的に困難な要件や重大な未知要素がある設計を調査する際は、マイルストーンを活用してプルーフオブコンセプトや「おもちゃの実装」を作成し、ユーザーの提案が実現可能かを検証してください。ライブラリのソースコードを見つけて読み込み、深く調査し、本格的な実装の指針となるプロトタイプを含めてください。

## 絶対要件

**譲れない要件：**

- すべての ExecPlan は完全に自己完結していなければなりません。自己完結とは、現在の形式で、初心者が成功するために必要なすべての知識と指示が含まれていることを意味します。
- すべての ExecPlan は生きた文書です。進捗に応じて、発見があった時、設計決定が確定した時に改訂することが求められます。各改訂版も完全に自己完結している必要があります。
- すべての ExecPlan は、このリポジトリの事前知識なしに、完全な初心者が機能を最初から最後まで実装できるものでなければなりません。
- すべての ExecPlan は、単に「定義を満たす」コード変更ではなく、実際に動作する振る舞いを生み出さなければなりません。
- すべての ExecPlan で使用する専門用語は平易な言葉で定義するか、使用を避けてください。

### 目的と意図を最優先に

まず数文で、ユーザーの視点から見てなぜこの作業が重要なのかを説明してください：この変更後に何ができるようになり、それまでは何ができなかったのか、そして動作を確認する方法を述べます。その後、読み手をその成果を達成するための具体的な手順（何を編集し、何を実行し、何を観察すべきか）に導いてください。

### エージェントの能力と制約

計画を実行するエージェントは、ファイルの一覧表示、読み取り、検索、プロジェクトの実行、テストの実行ができます。しかし、事前のコンテキストを知らず、以前のマイルストーンから意図を推測することもできません。依存する仮定はすべて繰り返し記載してください。外部のブログやドキュメントを参照するのではなく、必要な知識は計画自体にあなた自身の言葉で埋め込んでください。ExecPlan が以前の ExecPlan に基づいており、そのファイルがチェックインされている場合は、参照として組み込んでください。そうでない場合は、その計画からの関連するコンテキストをすべて含める必要があります。

## フォーマット規則

### 厳格なフォーマット要件

各 ExecPlan は、三連バッククォート（```）で始まり終わる`md`ラベル付きの単一のコードブロックでなければなりません。内部に追加の三連バッククォートのコードフェンスをネストしないでください。コマンド、トランスクリプト、差分、コードを表示する必要がある場合は、その単一フェンス内でインデントされたブロックとして提示してください。ExecPlan のコードフェンスを早期に閉じることを避けるため、ExecPlan 内部ではコードフェンスの代わりにインデントを使用してください。すべての見出しの後に 2 つの改行を使用し、#や##などを使用し、順序付きリストと順序なしリストの正しい構文を使用してください。

### Markdown ファイル作成時の注意

ExecPlan を Markdown（.md）ファイルに書く際、ファイルの内容が単一の ExecPlan のみである場合は、三連バッククォートを省略してください。

### 文体について

平易な散文で書いてください。リストよりも文章を優先します。簡潔さが意味を不明瞭にしない限り、チェックリスト、表、長い列挙は避けてください。チェックリストは「進捗」セクションでのみ許可され、そこでは必須です。説明セクションは散文形式を維持しなければなりません。

## ガイドライン

### 自己完結性と平易な言葉の重要性

通常の英語（日本語）ではない用語（「デーモン」「ミドルウェア」「RPC ゲートウェイ」「フィルタグラフ」など）を導入する場合は、すぐに定義し、このリポジトリでどのように現れるかを読み手に伝えてください（例：それが現れるファイルやコマンドを名前で示す）。「以前に定義したように」や「アーキテクチャドキュメントによると」などと言わないでください。必要な説明をここに含め、繰り返しになっても構いません。

### よくある失敗を避ける

- 未定義の専門用語に依存しない
- 機能の「文字通りの定義」を狭く記述して、コンパイルは通るが意味のあることを何もしないコードを作らない
- 重要な決定を読み手に委ねない
- 曖昧さが存在する場合は、計画自体で解決し、その道を選んだ理由を説明する
- ユーザーに見える効果は過剰に説明し、付随的な実装の詳細は控えめに記述する

### 観察可能な成果でアンカーする

実装後にユーザーができること、実行するコマンド、見るべき出力を明記してください。受け入れ条件は、内部属性（「HealthCheck 構造体を追加した」）ではなく、人間が検証できる振る舞い（「サーバー起動後、http://localhost:8080/health にアクセスすると、本文 OK で HTTP 200 が返される」）として表現してください。変更が内部的なものである場合は、その影響をどのように実証できるかを説明してください（例：変更前は失敗し変更後は成功するテストの実行、新しい動作を使用するシナリオの提示）。

### リポジトリコンテキストの明確な指定

ファイルはリポジトリルートからの完全パスで、関数やモジュールは正確に名前を指定し、新しいファイルをどこに作成すべきかを記述してください。複数の領域に触れる場合は、初心者が自信を持ってナビゲートできるよう、それらの部分がどのように組み合わさるかを説明する短い導入段落を含めてください。コマンドを実行する際は、作業ディレクトリと正確なコマンドラインを示してください。結果が環境に依存する場合は、前提条件を述べ、合理的な代替案を提供してください。

### 冪等性と安全性

手順は複数回実行してもダメージやドリフトを引き起こさないように記述してください。手順が途中で失敗する可能性がある場合は、リトライまたは適応方法を含めてください。移行や破壊的な操作が必要な場合は、バックアップや安全なフォールバックを詳しく説明してください。進行中に検証可能な、追加的でテスト可能な変更を優先してください。

### 検証は必須

テストの実行、該当する場合はシステムの起動、有用な動作の観察方法を含めてください。新機能や能力について包括的なテストを記述してください。初心者が成功と失敗を区別できるよう、期待される出力とエラーメッセージを含めてください。可能な限り、変更がコンパイル以上に効果的であることを証明する方法を示してください（例：小規模なエンドツーエンドのシナリオ、CLI の呼び出し、HTTP リクエスト/レスポンスのトランスクリプト）。プロジェクトのツールチェーンに適した正確なテストコマンドと、その結果の解釈方法を述べてください。

### 証拠の記録

手順がターミナル出力、短い差分、またはログを生成する場合は、単一のコードブロック内にインデントされた例として含めてください。成功を証明するものに焦点を当て、簡潔に保ってください。パッチを含める必要がある場合は、大きなブロブを貼り付けるのではなく、読み手があなたの指示に従って再作成できるファイルスコープの差分や小さな抜粋を優先してください。

## マイルストーン

### マイルストーンは物語であり、官僚主義ではない

作業をマイルストーンに分割する場合、それぞれを簡潔な段落で紹介してください：スコープ、マイルストーンの終わりに存在するが以前は存在しなかったもの、実行するコマンド、観察することを期待する受け入れ条件を記述します。物語として読みやすく保ってください：目標、作業、結果、証明。進捗とマイルストーンは別物です：マイルストーンは物語を語り、進捗は詳細な作業を追跡します。両方が存在しなければなりません。簡潔さのためだけにマイルストーンを省略してはならず、将来の実装にとって重要となりうる詳細を省かないでください。

各マイルストーンは独立して検証可能であり、実行計画の全体的な目標を段階的に実装するものでなければなりません。

## 生きた計画と設計決定

### ExecPlan は生きた文書

- 重要な設計決定を下したら、決定とその背後にある考えの両方を記録するように計画を更新してください。すべての決定を「決定ログ」セクションに記録してください。
- ExecPlan には「進捗」セクション、「驚きと発見」セクション、「決定ログ」、「成果と振り返り」セクションを含め、維持しなければなりません。これらは任意ではありません。
- オプティマイザーの動作、パフォーマンスのトレードオフ、予期しないバグ、アプローチを形作った逆/取り消しセマンティクスを発見した場合は、「驚きと発見」セクションに短い証拠スニペット（テスト出力が理想的）とともにその観察を記録してください。
- 実装の途中で方向転換した場合は、「決定ログ」にその理由を文書化し、「進捗」にその影響を反映させてください。計画はあなたのためのチェックリストであると同時に、次の貢献者のためのガイドです。
- 主要なタスクまたは計画全体の完了時に、達成したこと、残っていること、学んだ教訓をまとめた「成果と振り返り」エントリを書いてください。

## プロトタイピングマイルストーンと並行実装

### リスク軽減のためのプロトタイピング

より大きな変更のリスクを軽減する場合、明示的なプロトタイピングマイルストーンを含めることは許容され、しばしば推奨されます。例：実現可能性を検証するために依存関係に低レベルオペレーターを追加する、オプティマイザーの効果を測定しながら 2 つの構成順序を探る。プロトタイプは追加的でテスト可能に保ってください。スコープを「プロトタイピング」として明確にラベル付けし、実行方法と結果の観察方法を記述し、プロトタイプを昇格または破棄する基準を述べてください。

### 段階的な変更戦略

テストが通過し続ける追加的なコード変更とそれに続く削除を優先してください。並行実装（例：大規模な移行中にアダプターを古いパスと並行して保持する）は、リスクを減らしたり、大規模な移行中にテストが通過し続けることを可能にする場合は問題ありません。両方のパスを検証する方法と、テストで安全に 1 つを廃止する方法を記述してください。複数の新しいライブラリや機能領域を扱う場合は、これらの機能の実現可能性を互いに独立して評価するスパイクを作成することを検討してください。外部ライブラリが期待通りに動作し、必要な機能を単独で実装することを証明します。

## 優れた ExecPlan の骨組み

```md
# <短く、行動指向の説明>

この ExecPlan は生きた文書です。「進捗」「驚きと発見」「決定ログ」「成果と振り返り」セクションは、作業が進むにつれて最新状態に保たれなければなりません。

PLANS.md ファイルがリポジトリにチェックインされている場合は、リポジトリルートからそのファイルへのパスをここに参照し、この文書が PLANS.md に従って維持されなければならないことを記載してください。

## 目的 / 全体像

この変更後に誰かが得られるものと、それが動作することをどのように確認できるかを数文で説明してください。あなたが可能にするユーザーに見える振る舞いを述べてください。

## 進捗

チェックボックス付きのリストを使用して、詳細な手順を要約してください。部分的に完了したタスクを 2 つ（「完了」対「残り」）に分割する必要がある場合でも、すべての停止点をここに文書化しなければなりません。このセクションは常に作業の実際の現在の状態を反映していなければなりません。

- [x] (2025-10-01 13:00Z) 完了した手順の例
- [ ] 未完了の手順の例
- [ ] 部分的に完了した手順の例（完了：X；残り：Y）

進捗率を測定するためにタイムスタンプを使用してください。

## 驚きと発見

実装中に発見された予期しない動作、バグ、最適化、または洞察を文書化してください。簡潔な証拠を提供してください。

- 観察：…
  証拠：…

## 決定ログ

計画に取り組む中で下されたすべての決定を次の形式で記録してください：

- 決定：…
  理由：…
  日付/作成者：…

## 成果と振り返り

主要なマイルストーンまたは完了時に、成果、ギャップ、学んだ教訓を要約してください。結果を元の目的と比較してください。

## コンテキストと方向性

読み手が何も知らないかのように、このタスクに関連する現在の状態を記述してください。主要なファイルとモジュールを完全パスで名前を挙げてください。使用する明白でない用語を定義してください。以前の計画を参照しないでください。

## 作業計画

編集と追加の順序を散文で記述してください。各編集について、ファイルと場所（関数、モジュール）と、挿入または変更する内容を名前を挙げてください。具体的で最小限に保ってください。

## 具体的な手順

実行する正確なコマンドと、それらをどこで実行するか（作業ディレクトリ）を述べてください。コマンドが出力を生成する場合は、読み手が比較できるように短い期待されるトランスクリプトを示してください。このセクションは作業が進むにつれて更新されなければなりません。

## 検証と受け入れ

システムを起動または実行する方法と、何を観察するかを記述してください。受け入れを、特定の入力と出力を持つ振る舞いとして表現してください。テストが関係する場合は、「<プロジェクトのテストコマンド>を実行し、<N>個が合格することを期待します；新しいテスト<名前>は変更前に失敗し、変更後に合格します」と言ってください。

## 冪等性と回復

手順を安全に繰り返すことができる場合は、そう言ってください。手順にリスクがある場合は、安全なリトライまたはロールバックパスを提供してください。完了後に環境をきれいに保ってください。

## 成果物とメモ

最も重要なトランスクリプト、差分、またはスニペットをインデントされた例として含めてください。成功を証明するものに焦点を当て、簡潔に保ってください。

## インターフェースと依存関係

使用するライブラリ／モジュール／外部サービスと採用理由を明記。マイルストーン終了時点で存在する型・インターフェース・関数シグネチャを示し、参照は ESM のパスで固定してください（例：@/lib/tasks/service や app/api/tasks/route.ts）。
例として：
In src/lib/tasks/service.ts, 定義:

    export type Task = { id: string; title: string; done: boolean };

    export interface TaskService {
    getById(id: string): Promise<Task | null>;
    add(input: Pick<Task, "title">): Promise<Task>;
    }
    // usage: import { TaskService } from "@/lib/tasks/service";
```

上記のガイダンスに従えば、単一の状態を持たないエージェント（または人間の初心者）があなたの ExecPlan を上から下まで読んで、動作する観察可能な結果を生み出すことができます。それが基準です：**自己完結**、**自己充足**、**初心者ガイド**、**成果重視**。

計画を改訂する際は、生きた文書セクションを含むすべてのセクションに変更が包括的に反映されていることを確認し、計画の最後に変更とその理由を説明するメモを書かなければなりません。ExecPlan は、ほぼすべてについて「何を」だけでなく「なぜ」を記述しなければなりません。
