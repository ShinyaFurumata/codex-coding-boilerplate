Codex ExecPlans:

この文書は、ExecPlan の要件を説明します。ExecPlan は、コーディングエージェントが機能やシステム変更を動作する形で実装するために従う設計文書です。読者はこのリポジトリに不慣れな初心者であると仮定してください：彼らが持っているのは現在の作業ツリーと、あなたが提供する単一の ExecPlan ファイルだけです。過去の計画の記憶や外部コンテキストはありません。

ExecPlans と PLANS.md の使い方

実行可能な仕様（ExecPlan）を書くときは、PLANS.md に忠実に従ってください。もし手元に PLANS.md が無ければ、全文を読み返して理解を取り戻してください。正確な仕様を書くために、ソース資料を丁寧に（何度も）読み込んでください。仕様を作る際は、まず骨組み（スケルトン）から始め、調査を進めながら肉付けしてください。

実行可能な仕様（ExecPlan）を実装する際は、ユーザーに「次の手順は？」と尋ねてはいけません。単純に次のマイルストーンへ進んでください。すべてのセクションを最新に保ち、作業を止めるたびにリストの項目を追加・分割して、進捗と次の手順を明示してください。曖昧さは自律的に解決し、こまめにコミットしてください。

ExecPlan を議論する際は、仕様内のログに決定事項を記録してください。どの変更がなぜ行われたのかが明確でなければなりません。ExecPlans は生きた文書です。常に「その ExecPlan のみ」から再開できるようにしておくべきです。

要求が厳しい設計や不確定要素が多い場合は、マイルストーンを使ってプルーフ・オブ・コンセプトや小さい実装（toy implementations）を行い、提案が実際に実現可能かを検証してください。ライブラリのソースコードは入手して読み込み、深く調査し、プロトタイプを含めて本実装の指針を示してください。

要件

譲れない要件（NON-NEGOTIABLE REQUIREMENTS）:
• すべての ExecPlan は完全に自己完結していなければならない。自己完結とは、現状の形で初心者が成功するために必要な知識と指示をすべて含んでいることを意味する。
• すべての ExecPlan は生きた文書であること。貢献者は進捗や発見、設計決定があったときにそれを更新する義務がある。各改訂は依然として自己完結でなければならない。
• すべての ExecPlan は、リポジトリに関する事前知識がない完全な初心者でもその機能を端から端まで実装できるようにしなければならない。
• すべての ExecPlan は、単に「定義に沿ったコード変更」をするだけでなく、実証可能な動作を生み出さなければならない。
• すべての ExecPlan は、専門用語を使う場合はそれを平易な言葉で定義するか、もしくは専門用語を使用しないこと。

目的と意図を最優先にしてください。まず、数文で作業がユーザーにとってなぜ重要かを説明してください：この変更によって以前はできなかった何ができるようになるのか、どのように動作を確認するかを示してください。その後、結果を得るための正確な手順（何を編集し、何を実行し、何を観察するか）を案内してください。

あなたの計画を実行するエージェントは、ファイルの列挙、ファイルの読み取り、検索、プロジェクトの実行、テストの実行が可能です。過去の文脈を知らず、以前のマイルストーンから何を意味したかを推測できないことに留意してください。依存している仮定はすべて繰り返してください。外部のブログやドキュメントへの参照は避け、必要な知識があれば計画の中に自分の言葉で埋め込んでください。もし ExecPlan が別の ExecPlan に基づいている場合で、そのファイルがリポジトリにチェックインされていれば参照を含めてください。されていなければ、その計画のすべての関連コンテキストを含めなければなりません。

フォーマット

フォーマットと外枠はシンプルかつ厳格です。各 ExecPlan は md ラベルの付いた単一のフェンス付きコードブロック（トリプルバッククォートで始まり終わる）である必要があります。内部に追加のトリプルバッククォートを入れないでください。コマンドやトランスクリプト、差分、コードを示す必要があるときは、その単一のフェンスの内部でインデントされたブロックとして提示してください。ExecPlan 内のコードフェンスを早期に閉じてしまわないように、インデントで明瞭に示してください。見出しの後には必ず 2 行改行を入れ、# や ## を正しく使い、順序付けられた/順不同リストの構文を正しく使ってください。

もし ExecPlan を格納する Markdown (.md) ファイルの内容がその単一の ExecPlan のみで構成される場合、トリプルバッククォートは省略してください。

本文は平易な散文で書いてください。リストより文章を優先してください。チェックリスト、表、長い列挙は、冗長さが意味を損なう場合を除いて避けてください。Progress セクションではチェックリストが許可されており、かつ必須です。物語風の説明は散文を優先してください。

ガイドライン

自己完結性と平易さが最重要です。もし普通の英語でない表現（“daemon”、“middleware”、“RPC gateway”、“filter graph” など）を導入するなら、その場で即座に定義し、リポジトリ内でそれがどのファイルやコマンドとして現れるかを示してください。「前述の定義に従う」や「アーキテクチャ文書に従う」と書かないでください。必要な説明はここに含めてください（繰り返しになっても構いません）。

よくある失敗モードを避けてください。未定義の専門用語に依存しないでください。機能の「字面」だけ説明して結果的にコードがコンパイルするが意味をなさない、ということが起きないようにしてください。重要な決断を読者に丸投げしないでください。曖昧さがある場合は、計画内でそれを解決し、なぜその道を選んだかを説明してください。ユーザーに見える効果は多めに説明し、実装上の些細な詳細は控えめに指定してください。

計画は観測可能な成果で結びつけてください。実装後にユーザーが何をできるか、実行するコマンド、観察すべき出力を明示してください。受け入れ基準は人間が検証可能な振る舞いで表現してください（例：「サーバーを起動後、 http://localhost:8080/health にアクセスすると HTTP 200 と OK が返る」） — 内部的な属性（「HealthCheck 構造体を追加した」）だけではなく、外側に見える動作で述べてください。内部変更のみのときでも、その影響をどう示すか（例えば、あるテストが変更前は失敗し、変更後は通る、など）を説明してください。

リポジトリの文脈を明示してください。ファイルはリポジトリ相対パスで正確に名前を示し、関数やモジュールも正確に指定してください。新しいファイルをどこに作るかを記述してください。複数箇所に触れる場合は、それらがどのように繋がるか短く説明するオリエンテーションを入れ、初心者が自信を持ってナビゲートできるようにしてください。コマンドを実行するときは作業ディレクトリと正確なコマンドラインを示してください。環境依存の結果がある場合は前提条件を述べ、合理的な代替案を提示してください。

冪等性（idempotence）と安全性を確保してください。手順は複数回実行しても害やドリフトを起こさないように書いてください。途中で失敗する可能性があるステップがあるなら、再試行方法や適応方法を含めてください。マイグレーションや破壊的操作が必要な場合は、バックアップや安全なフォールバック手順を明記してください。追加的でテスト可能な変更を優先し、段階的に検証できるようにしてください。

検証は必須です。テストの実行方法、システムの起動方法、およびそれが何か有用なことをしている様子の観察法を含めてください。新しい機能については包括的なテストを記述し、期待される出力やエラーメッセージを示して初心者が成功と失敗を判別できるようにしてください。可能ならば、コンパイルを超えて変更の有効性を実証できる方法（小さなエンドツーエンドシナリオ、CLI 呼び出し、HTTP のリクエスト/レスポンスのやり取りなど）を示してください。プロジェクトのツールチェーンに適した正確なテストコマンドとその結果の解釈方法を示してください。

証拠の収集を行ってください。手順の実行が端末出力や短い差分、ログを生む場合、それらを単一のフェンス内にインデントされた例として含めてください。成功を証明するために簡潔で焦点を絞ったものにしてください。パッチを含める場合は、読者が手順に従って再現できるようにファイル単位の差分や小さな抜粋を使うことを推奨します。大きな塊をそのまま貼るのは避けてください。

マイルストーン

マイルストーンは物語的に書いてください。作業をマイルストーンに分ける場合、それぞれの冒頭にその範囲を説明する短い段落を入れ、マイルストーンの終わりに何が新しく存在するか（それまでになかったもの）、実行するコマンド、期待する受け入れ観察を述べてください。読みやすい物語として書くこと：目標、作業、結果、証明。Progress（進捗）と Milestones（マイルストーン）は別物です。マイルストーンは物語を語り、Progress は細かな作業を追跡します。どちらも必要です。省略して簡略化しないでください。将来の実装で重要になり得る詳細を省くべきではありません。

各マイルストーンは独立して検証可能であり、かつ ExecPlan 全体の目標を段階的に実現するものにしてください。

生きた計画と設計決定
• ExecPlans は生きた文書です。重要な設計決定をしたら、その計画を更新して決定内容とその背景（思考過程）を記録してください。Decision Log セクションにすべての決定を記録してください。
• ExecPlans は Progress、Surprises & Discoveries、Decision Log、Outcomes & Retrospective の各セクションを含み維持しなければなりません。これらは必須です。
• オプティマイザの挙動、性能トレードオフ、予期せぬバグ、逆適用（inverse/unapply）セマンティクスなど、実装中に方針に影響した観察は Surprises & Discoveries に短い証拠付きで記録してください（テスト出力が理想的です）。
• 実装中に方針変更をした場合は、その理由を Decision Log に書き、Progress に反映させてください。計画は次の貢献者のためのガイドであると同時にあなたのチェックリストであるべきです。
• 大きなタスクや計画の完了時には Outcomes & Retrospective に、達成したこと、残っていること、学びを書き残してください。

プロトタイピングのマイルストーンと並行実装

大きな変更のリスクを減らすために、明示的なプロトタイピングのマイルストーンを含めることは許容され、かつ推奨されます。例：依存関係に低レベルのオペレータを追加して実現可能性を検証する、異なる合成順序を試してオプティマイザへの影響を測るなど。プロトタイプは追加的かつテスト可能にしてください。範囲に「プロトタイピング」と明示し、実行・観察方法、採用/廃棄の基準を示してください。

追加的なコード変更を行い、それをテストが通る形で後続の減算（削除）で整理することを優先してください。並列実装（移行中にアダプタを残すなど）は、リスク低減やテスト継続のために許容されます。両方の経路を検証する方法と、安全に片方を退役させる手順を記述してください。複数の新ライブラリや機能領域で作業する場合は、それらを個別に評価するスパイク（spike）を作成し、外部ライブラリが期待する機能を単独で満たすかを検証してください。

良い ExecPlan の骨組み（Skeleton）

    # 実行計画（短く、実行志向の説明）

    このExecPlanは「生きたドキュメント」です。
    `進捗`, `発見・驚き`, `決定ログ`, `成果・振り返り` の各セクションは、作業の進行に合わせて常に最新の状態に保ちます。

    もし `PLANS.md` ファイルがリポジトリに含まれている場合は、そのリポジトリルートからのパスをここに記載し、本ドキュメントがPLANS.mdに準拠して保守されることを明記してください。

    ---

    ## 目的 / 全体像

    この変更によって何が得られ、どのように動作を確認できるのかを簡潔に説明してください。
    ユーザーから見える挙動を明示します。

    ---

    ## 進捗（Progress）

    チェックリスト形式で作業内容を記録します。
    中断点も必ず記載し、部分的な完了は「完了済み」と「残り」に分けて明確にします。
    このセクションは常に実際の進行状況を反映してください。

    - [x] (2025-10-01 13:00Z) 完了した例
    - [ ] 未完了の例
    - [ ] 一部完了の例（完了: X; 残り: Y）

    進捗速度を把握するため、タイムスタンプを付与します。

    ---

    ## 発見・驚き（Surprises & Discoveries）

    実装中に発生した予期せぬ挙動、バグ、最適化、洞察などを記録します。
    簡潔な証拠を添えてください。

    - 観察: …
    証拠: …

    ---

    ## 決定ログ（Decision Log）

    作業中に行ったすべての決定を以下の形式で記録します。

    - 決定: …
    理由: …
    日付／記録者: …

    ---

    ## 成果・振り返り（Outcomes & Retrospective）

    マイルストーン到達時や完了時に、成果・課題・学びをまとめます。
    結果を初期目的と比較してください。

    ---

    ## 現状と背景（Context and Orientation）

    このタスクに関する現状を、初めて読む人にもわかるように説明します。
    関連ファイルやモジュールのフルパスを明記し、専門用語は定義します。
    過去の計画には言及しません。

    ---

    ## 作業計画（Plan of Work）

    編集や追加の手順を文章で説明します。
    各変更点について、対象ファイルと位置（関数・モジュール名）を示し、
    何を変更・追加するのかを具体的かつ最小限に書きます。

    ---

    ## 具体的な手順（Concrete Steps）

    実行するコマンドと、その作業ディレクトリを明示します。
    出力がある場合は、比較できるように短いサンプルを示します。
    作業の進行に合わせて更新してください。

    ---

    ## 検証と受け入れ条件（Validation and Acceptance）

    システムの起動・確認方法を説明し、期待される挙動を具体的に示します。
    入力と出力をセットで記述し、テストを使う場合は以下のように書きます：

    > 「`<プロジェクトのテストコマンド>` を実行し、<N>件成功することを確認。
    > 新しいテスト `<name>` は変更前は失敗し、変更後に成功すること。」

    ---

    ## 再実行とリカバリ（Idempotence and Recovery）

    手順が安全に再実行できる場合はその旨を明記します。
    リスクのある手順には、安全なリトライまたはロールバック方法を提示し、
    完了後は環境をクリーンな状態に保ちます。

    ---

    ## 成果物とメモ（Artifacts and Notes）

    重要なログ、差分、コード断片などを抜粋として掲載します。
    成功を示すために必要な範囲で、簡潔にまとめてください。

    ---

    ## インターフェースと依存関係（Interfaces and Dependencies）

    使用するライブラリ／モジュール／外部サービスと採用理由を明記。マイルストーン終了時点で存在する型・インターフェース・関数シグネチャを示し、参照は ESM のパスで固定してください（例：@/lib/tasks/service や app/api/tasks/route.ts）。
    例として：
    In src/lib/tasks/service.ts, 定義:

        export type Task = { id: string; title: string; done: boolean };

        export interface TaskService {
        getById(id: string): Promise<Task | null>;
        add(input: Pick<Task, "title">): Promise<Task>;
        }
        // usage: import { TaskService } from "@/lib/tasks/service";

もし上のガイダンスに従えば、単一のステートレスなエージェント――または初心者の人間――が ExecPlan を上から下まで読み、動作する、観測可能な結果を作り出せるはずです。基準は次の通りです：自己完結、自己完結であること、自律的に実行可能であること、初心者を導けること、そして結果にフォーカスしていること。

変更を加えた場合は、必ず計画全体のすべてのセクション（生きた文書セクションを含む）にその変更が反映されていることを確認し、最後にその変更内容と理由を本文の下部に記述してください。ExecPlans は「何をするか」だけでなく、ほとんどすべての事項について「なぜそうするか」も説明しなければなりません。
